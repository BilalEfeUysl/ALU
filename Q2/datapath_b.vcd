$date
	Mon Apr 14 22:03:44 2025
$end
$version
	Icarus Verilog
$end
$timescale
	1ps
$end
$scope module tb_datapath_b $end
$var wire 32 ! result [31:0] $end
$var reg 3 " ALUControl [2:0] $end
$var reg 2 # addr1 [1:0] $end
$var reg 2 $ addr2 [1:0] $end
$var reg 2 % addr3 [1:0] $end
$var reg 1 & clk $end
$var reg 1 ' rst $end
$var reg 1 ( wr $end
$scope module dut $end
$var wire 3 ) ALUControl [2:0] $end
$var wire 2 * addr1 [1:0] $end
$var wire 2 + addr2 [1:0] $end
$var wire 2 , addr3 [1:0] $end
$var wire 1 & clk $end
$var wire 1 ' rst $end
$var wire 1 ( wr $end
$var wire 32 - result [31:0] $end
$var wire 32 . data2 [31:0] $end
$var wire 32 / data1 [31:0] $end
$scope module alu $end
$var wire 3 0 ALUControl [2:0] $end
$var wire 32 1 xorResult [31:0] $end
$var wire 32 2 subResult [31:0] $end
$var wire 32 3 sltResult [31:0] $end
$var wire 32 4 result [31:0] $end
$var wire 32 5 b [31:0] $end
$var wire 32 6 andResult [31:0] $end
$var wire 32 7 addResult [31:0] $end
$var wire 32 8 a [31:0] $end
$scope module add_inst $end
$var wire 32 9 result [31:0] $end
$var wire 1 : subtract $end
$var wire 32 ; b [31:0] $end
$var wire 32 < a [31:0] $end
$upscope $end
$scope module and_inst $end
$var wire 32 = result [31:0] $end
$var wire 32 > b [31:0] $end
$var wire 32 ? a [31:0] $end
$upscope $end
$scope module mux_inst $end
$var wire 32 @ addResult [31:0] $end
$var wire 32 A andResult [31:0] $end
$var wire 3 B sel [2:0] $end
$var wire 32 C xorResult [31:0] $end
$var wire 32 D subResult [31:0] $end
$var wire 32 E sltResult [31:0] $end
$var reg 32 F result [31:0] $end
$upscope $end
$scope module slt_inst $end
$var wire 32 G result [31:0] $end
$var wire 32 H b [31:0] $end
$var wire 32 I a [31:0] $end
$upscope $end
$scope module sub_inst $end
$var wire 32 J result [31:0] $end
$var wire 1 K subtract $end
$var wire 32 L b [31:0] $end
$var wire 32 M a [31:0] $end
$upscope $end
$scope module xor_inst $end
$var wire 32 N result [31:0] $end
$var wire 32 O b [31:0] $end
$var wire 32 P a [31:0] $end
$upscope $end
$upscope $end
$scope module rf $end
$var wire 2 Q addr1 [1:0] $end
$var wire 2 R addr2 [1:0] $end
$var wire 2 S addr3 [1:0] $end
$var wire 1 & clk $end
$var wire 32 T data1 [31:0] $end
$var wire 32 U data2 [31:0] $end
$var wire 32 V data3 [31:0] $end
$var wire 1 ' rst $end
$var wire 1 ( wr $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
$end
#0
$dumpvars
b0 V
bx U
bx T
bx S
bx R
bx Q
bx P
bx O
bx N
bx M
bx L
1K
bx J
bx I
bx H
b0x G
b0 F
b0x E
bx D
bx C
bx B
bx A
bx @
bx ?
bx >
bx =
bx <
bx ;
0:
bx 9
bx 8
bx 7
bx 6
bx 5
b0 4
b0x 3
bx 2
bx 1
bx 0
bx /
bx .
b0 -
bx ,
bx +
bx *
bx )
0(
0'
0&
bx %
bx $
bx #
bx "
b0 !
$end
#10000
b0 3
b0 E
b0 G
b0 1
b0 C
b0 N
b10010001101000101011001111000 6
b10010001101000101011001111000 =
b10010001101000101011001111000 A
1(
b1 "
b1 )
b1 0
b1 B
b1 %
b1 ,
b1 S
b0 2
b0 D
b0 J
b100100011010001010110011110000 7
b100100011010001010110011110000 9
b100100011010001010110011110000 @
b10010001101000101011001111000 .
b10010001101000101011001111000 5
b10010001101000101011001111000 ;
b10010001101000101011001111000 >
b10010001101000101011001111000 H
b10010001101000101011001111000 L
b10010001101000101011001111000 O
b10010001101000101011001111000 U
b0 $
b0 +
b0 R
b10010001101000101011001111000 /
b10010001101000101011001111000 8
b10010001101000101011001111000 <
b10010001101000101011001111000 ?
b10010001101000101011001111000 I
b10010001101000101011001111000 M
b10010001101000101011001111000 P
b10010001101000101011001111000 T
b0 #
b0 *
b0 Q
1&
#20000
0&
#30000
b1 1
b1 C
b1 N
b1 3
b1 E
b1 G
b0 6
b0 =
b0 A
b11111111111111111111111111111111 !
b11111111111111111111111111111111 -
b11111111111111111111111111111111 4
b11111111111111111111111111111111 F
b11111111111111111111111111111111 V
1&
b0 %
b0 ,
b0 S
b1 .
b1 5
b1 ;
b1 >
b1 H
b1 L
b1 O
b1 U
b11 $
b11 +
b11 R
b11111111111111111111111111111111 2
b11111111111111111111111111111111 D
b11111111111111111111111111111111 J
b1 7
b1 9
b1 @
b0 /
b0 8
b0 <
b0 ?
b0 I
b0 M
b0 P
b0 T
b1 #
b1 *
b1 Q
#40000
0&
#50000
1&
b10 %
b10 ,
b10 S
#60000
0&
#70000
b0 1
b0 C
b0 N
b0 3
b0 E
b0 G
b11111111111111111111111111111111 6
b11111111111111111111111111111111 =
b11111111111111111111111111111111 A
b0 !
b0 -
b0 4
b0 F
b0 V
1&
b11 %
b11 ,
b11 S
b11111111111111111111111111111111 .
b11111111111111111111111111111111 5
b11111111111111111111111111111111 ;
b11111111111111111111111111111111 >
b11111111111111111111111111111111 H
b11111111111111111111111111111111 L
b11111111111111111111111111111111 O
b11111111111111111111111111111111 U
b0 $
b0 +
b0 R
b0 2
b0 D
b0 J
b11111111111111111111111111111110 7
b11111111111111111111111111111110 9
b11111111111111111111111111111110 @
b11111111111111111111111111111111 /
b11111111111111111111111111111111 8
b11111111111111111111111111111111 <
b11111111111111111111111111111111 ?
b11111111111111111111111111111111 I
b11111111111111111111111111111111 M
b11111111111111111111111111111111 P
b11111111111111111111111111111111 T
b0 #
b0 *
b0 Q
#80000
0&
#90000
1&
